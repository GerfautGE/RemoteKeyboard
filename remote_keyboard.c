#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <gui/view_dispatcher.h>

#include "remote_keyboard.h"
/* generated by fbt from .png files in images folder */
#include <remote_keyboard_icons.h>

struct RemoteKbApp {
    FuriThread* gui_thread;
    FuriThread* usb_thread;

    RemoteKbState state;
};

void remote_app_get_state(RemoteKbApp* app, RemoteKbState* state) {
    *state = app->state;
}

void thread_send_stop(FuriThread* thread) {
    furi_thread_flags_set(furi_thread_get_id(thread), ThreadStop);
}

static void app_draw_scene_callback(Canvas* canvas, void* ctx) {
    RemoteKbApp* app = ctx; // context is what is send to the drawer
    UNUSED(app);

    canvas_clear(canvas);
    canvas_draw_icon(canvas, 80, 8, &I_bluetooth); // bluetooth icon
    canvas_draw_icon(canvas, 48, 8, &I_arrow); // arrow icon
    canvas_draw_icon(canvas, 16, 8, &I_usb); // usb icon
    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 0, 48, (app->state.usb_connected) ? "Connected" : "No Conn"); // usb connection status
    canvas_draw_str(canvas, 64, 48, "No Conn"); // bluetooth connection status
}

static void app_input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);

    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

static int32_t gui_process(void* p) {
    RemoteKbApp* app = p;

    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, app_draw_scene_callback, app);
    view_port_input_callback_set(view_port, app_input_callback, event_queue);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    InputEvent event;
    bool running = true;
    while(running) {
        if(furi_message_queue_get(event_queue, &event, 100) == FuriStatusOk) {
            if((event.type == InputTypePress) || (event.type == InputTypeRepeat)) {
                switch(event.key) {
                case InputKeyUp:

                    break;
                case InputKeyBack:
                    running = false;
                    break;
                default:
                    break;
                }
            }
        }
        view_port_update(view_port);
    }

    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    //free view dispatcher
    furi_record_close(RECORD_GUI);

    return 0;
}

static int32_t usb_process(void* p) {
    RemoteKbApp* app = p;

    //init USB mode interface (HID)
    FuriHalUsbInterface* usb_prev_mode = furi_hal_usb_get_config();
    if(furi_hal_usb_is_locked()) {
        furi_hal_usb_unlock();
    }
    furi_check(furi_hal_usb_set_config(&usb_hid, NULL) == true);

    uint32_t events;
    while(true) {
        events = furi_thread_flags_wait(ThreadEventAll, FuriFlagWaitAny, FuriFlagWaitAll);

        if(furi_hal_hid_is_connected()){
            app->state.usb_connected = true;
        } else {
            app->state.usb_connected = false;
        }

        if(events & ThreadStop) {
            break;
        }
    }

    // reset USB Mode
    furi_hal_usb_set_config(usb_prev_mode, NULL);

    return 0;
}

RemoteKbApp* remotekb_app_alloc() {
    RemoteKbApp* app = malloc(sizeof(RemoteKbApp));
    app->gui_thread = furi_thread_alloc_ex("RemoteKbGui", 1024, gui_process, app);
    app->usb_thread = furi_thread_alloc_ex("RemoteKbUsb", 1024, usb_process, app);
    return app;
}

static void remotekb_app_free(RemoteKbApp* app) {
    furi_assert(app);
    furi_thread_free(app->gui_thread);
    furi_thread_free(app->usb_thread);
    free(app);
}

static RemoteKbApp* app_handle = NULL;

int32_t remote_keyboard_app(void* p) {
    UNUSED(p);

    //alloc app
    RemoteKbApp* app = remotekb_app_alloc();
    app_handle = app;

    //start threads
    furi_thread_start(app->usb_thread);
    furi_thread_start(app->gui_thread);

    //wait for gui thread to finish
    furi_thread_join(app->gui_thread);

    //send stop to other threads
    thread_send_stop(app->usb_thread);

    //wait for them to finish
    furi_thread_join(app->usb_thread);

    //free app
    remotekb_app_free(app);

    return 0;
}
